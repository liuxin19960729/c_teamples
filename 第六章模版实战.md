# 第六章模版实战
## 6.1 包含模型 
```
组织模版源代码有几种方式
包含模型 是其中最常用的一种
```
### 6.1.1 连接器错误
```cpp
头文件  .hpp 文件
   1.存放 class(类) 和 其他类型
   2. 全局函数 全局 变量的声明(定义放入.cpp文件)




myfirst.hpp

#ifndef __MYFIRST_HPP_
#define __MYFIRST_HPP_
template <typename T>
void print_typeof(T const &);
#endif

myfirst.cpp

#include <iostream>
#include "myfirst.hpp"

template <typename T>
void print_typeof(T const &x)
{
    std::cout << typeid(x).name() << endl;
}

myfirstmain.cpp
#include <iostream>
#include "myfirst.hpp"

int main(int argc, char const *argv[])
{
    print_typeof(100);
    return 0;
}

g++ -c myfirstmain.cpp myfirst.cpp -std=c++11
g++  myfirstmain.o myfirst.o -std=c++11
//错误 连接器连接失败

原因:
print_typeof 函数还没有被实例化

myfirst.cpp  myfirst 只是定义模版并未实例化模版
    myfirst.o

myfirstmain.cpp  未实例化 使用  myfirst.hpp 声明 表面在其他地方定义了函数 
    myfirstmain.o 

g++  myfirstmain.o myfirst.o -std=c++11
连接 两个.o都没有  print_typeof 的具体定义连接器找不到
```
### 6.1.2 头文件中的模版
```cpp
myfirst.hpp
#ifndef __MYFIRST_HPP_
#define __MYFIRST_HPP_
#include <iostream>
#include <typeinfo>
template <typename T>
void print_typeof(T const &x)
{
    std::cout << typeid(x).name() << std::endl;
}

#endif

头文件包含 模版定义和声明

这种组织的方式我们称为包含模型


包含模型 增加头文件 myfirst.hpp 的开销
myfirst.hpp 包含
#include <iostream>
#include <typeinfo>
两个头文件 我们使用 cout typeid endl 等会导致 这两个头文件模版实力化可能会导致成百上千行代码 这样会增加编译的复杂度


不包含创建期间的时间问题 建议使用包含模型


非内联模版函数,宏,内联函数

非内联函数模版在调用位置并不会扩展,当基于某种类型实例化之后才会参数一份新的函数拷贝
```
## 6.2 显示实例化
```
包含模型: 能够却行每个使用模版 都已经实例化
```
### 6.2.1 显示的实例化的例子
```
template void fun(const int &);
显示实例化类,它会默认实例化它的所有成员
template MyClass<int>
显示实例化类的构造函数
template MyClass<int>::MyClass();
注意 不能重复进行实例化已经实例化的 类 函数 ...



人工实例化缺点:
必须人工跟随所有实例化实体,对于大项目来说人工的跟随,会非常的困难


```